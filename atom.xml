<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[code]]></title>
  <link href="http://vladimir-vg.github.io/atom.xml" rel="self"/>
  <link href="http://vladimir-vg.github.io/"/>
  <updated>2014-05-26T12:53:46+03:00</updated>
  <id>http://vladimir-vg.github.io/</id>
  <author>
    <name><![CDATA[Gordeev Vladimir]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Армия]]></title>
    <link href="http://vladimir-vg.github.io/blog/2013/04/22/army/"/>
    <updated>2013-04-22T13:48:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2013/04/22/army</id>
    <content type="html"><![CDATA[<p>Завтра, 23-го апреля в 6:00 утра я ухожу в армию на год. Соотвественно,
я не смогу писать в блог, делать какие-то эксперименты в течение этого года.</p>

<p>Надеюсь что я за этот год стану лучше.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[«Ненормальное ООП». Выступление на калининградской конфе ForkConf]]></title>
    <link href="http://vladimir-vg.github.io/blog/2013/03/05/forkconf-oop-talk/"/>
    <updated>2013-03-05T19:07:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2013/03/05/forkconf-oop-talk</id>
    <content type="html"><![CDATA[<p>3 марта, два дня назад мне довелось выступать на местной калининградской
IT-конференции под названием <a href="http://www.forkconf.ru/">ForkConf</a>.
<a href="http://www.forkconf.ru/2013/03/old-good-time.html">Анонс</a>.</p>

<p>Саму презентацию можно <a href="http://vladimir-vg.github.com/forkconf-oop-talk">увидеть здесь</a>. <a href="https://github.com/vladimir-vg/forkconf-oop-talk">А здесь лежат её исходники</a>. </p>

<p>Тема выступления – «Ненормальное ООП». Я осознаю что на данный момент
львиная доля программистов посещающих конфу пишут на PHP, Java, C++, C#.
Подумал, что было бы весело взорвать их мозг разными гибкими возможностями
доступными в других языках. =)</p>

<p>Так как я зарабатываю на хлеб использую Ruby on Rails, и лучше всего знаю именно
Ruby, то и код на слайдах почти весь на Ruby.</p>

<p>Выступление получилось довольно поверхностным, более глубоко стоит рассказывать
для более подготовленной аудитории. Пока так.</p>

<p>Затронул тему прототипов, классов как объектов. Рассказал про миксины и трейты.
Ещё показал в чём разница между посылкой сообщения и простым вызовом метода.</p>

<p>Ещё хотел рассказать про декомпозицию классов и методов (как в CLOS и Factor),
а также про метаклассы, но понял что это будет слишком толсто и лучше в другой раз.</p>

<p>Это моё первое выступление такого рода, поэтому я слишком торопился рассказывая,
и похоже не давал времени аудитории переварить код на слайдах. Кроме того,
похоже нужно гораздо больше кода, больше примеров, чтобы было рельно понятно.</p>

<p>Такие дела.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Как ограничить набор типов реализующих интерфейс в Go?]]></title>
    <link href="http://vladimir-vg.github.io/blog/2013/01/22/restrict-interface-responders/"/>
    <updated>2013-01-22T00:01:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2013/01/22/restrict-interface-responders</id>
    <content type="html"><![CDATA[<p>Когда есть свободное время я разбираюсь с языком Go, пытаюсь разобраться с его
внутренностями, пытаюсь писать какие-то проекты с его помощью.</p>

<p>В Go вводится ряд новшеств, которых нет в других хорошо развитых и популярных
языках. Соответственно, код на Go не похож на код на Java или C++, слишком уж
разный набор фич, совсем другие средства выражения.</p>

<p>Наткнулся на прикольный способ искусственно ограничить список типов
удовлетворяющих интерфейсу.</p>

<h1 id="section">Ограничение набора типов реализующих конкретный интерфейс</h1>

<p>К примеру если хочется использовать в своей <code>FooFunc</code> функции параметр <code>a</code>,
так, чтобы a мог быть разных типов, но при этом нет одного интерфейса их объединяющего,
с помощью которого можно было бы абстрагироваться.
В таких случаях используют тип <code>interface{}</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">func</span> FooFunc(a <span class="keyword">interface</span>{}) {
    <span class="comment">// do what ever you want</span>
}
</pre></div>
</div>
</div>

<p>Но так как как функция публичная, видимая извне, то может оказаться так,
что в качестве <code>a</code> передадут не то значение что ожидает ваш код.</p>

<p>Как раз на этот случай есть следующий трюк, можно объявить специальный интерфейс,
который требует реализации лишь одного приватного метода-заглушки. Далее можно
объявить методы для типов которые хочется использовать, тогда тип <code>a</code> будет
проверяться на стадии компиляции.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">type</span> aTypeInterface <span class="keyword">interface</span> {
    aMethod()
}

<span class="keyword">func</span> FooFunc(a aTypeInterface) {
    <span class="comment">// do what ever you want</span>
}

<span class="keyword">func</span> (bType) aMethod(){}
<span class="keyword">func</span> (cType) aMethod(){}
<span class="keyword">func</span> (dType) aMethod(){}
</pre></div>
</div>
</div>

<p>Теперь параметр <code>a</code> в функции <code>FooFunc</code> может быть лишь одним из указанных
типов: <code>bType</code>, <code>cType</code>, <code>dType</code>, и это проверяется на стадии компиляции.</p>

<p>Наткнулся на такой код в пакете стандартной библиотеки <code>go/ast/ast.go</code>:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="comment">/* ... skipped ... */</span>

<span class="comment">// All node types implement the Node interface.</span>
<span class="keyword">type</span> Node <span class="keyword">interface</span> {
    Pos() token.Pos <span class="comment">// position of first character belonging to the node</span>
    End() token.Pos <span class="comment">// position of first character immediately after the node</span>
}

<span class="comment">// All statement nodes implement the Stmt interface.</span>
<span class="keyword">type</span> Stmt <span class="keyword">interface</span> {
    Node
    stmtNode()
}

<span class="comment">/* ... skipped ... */</span>

<span class="comment">// stmtNode() ensures that only statement nodes can be</span>
<span class="comment">// assigned to a StmtNode.</span>
<span class="comment">//</span>
<span class="keyword">func</span> (*BadStmt) stmtNode()        {}
<span class="keyword">func</span> (*DeclStmt) stmtNode()       {}
<span class="keyword">func</span> (*EmptyStmt) stmtNode()      {}
<span class="keyword">func</span> (*LabeledStmt) stmtNode()    {}
<span class="keyword">func</span> (*ExprStmt) stmtNode()       {}
<span class="keyword">func</span> (*SendStmt) stmtNode()       {}
<span class="keyword">func</span> (*IncDecStmt) stmtNode()     {}
<span class="keyword">func</span> (*AssignStmt) stmtNode()     {}
<span class="keyword">func</span> (*GoStmt) stmtNode()         {}
<span class="keyword">func</span> (*DeferStmt) stmtNode()      {}
<span class="keyword">func</span> (*ReturnStmt) stmtNode()     {}
<span class="keyword">func</span> (*BranchStmt) stmtNode()     {}
<span class="keyword">func</span> (*BlockStmt) stmtNode()      {}
<span class="keyword">func</span> (*IfStmt) stmtNode()         {}
<span class="keyword">func</span> (*CaseClause) stmtNode()     {}
<span class="keyword">func</span> (*SwitchStmt) stmtNode()     {}
<span class="keyword">func</span> (*TypeSwitchStmt) stmtNode() {}
<span class="keyword">func</span> (*CommClause) stmtNode()     {}
<span class="keyword">func</span> (*SelectStmt) stmtNode()     {}
<span class="keyword">func</span> (*ForStmt) stmtNode()        {}
<span class="keyword">func</span> (*RangeStmt) stmtNode()      {}
</pre></div>
</div>
</div>

<p>Пример именно такого подхода</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Есть ли случаи, когда Си лучше C++?]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/12/18/does-c-always-better-than-cpp/"/>
    <updated>2012-12-18T10:43:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/12/18/does-c-always-better-than-cpp</id>
    <content type="html"><![CDATA[<p>Вопрос с <a href="http://hashcode.ru/questions/174571/">таким заголовком запостил один парень на хэшкоде</a>.</p>

<blockquote>
  <p>Здравствуйте. Вопрос из заголовка переписывать не буду.</p>

  <p>Интересуют реальные примеры, т.е. не те, когда компилятора C++ под <em>какую-то</em> платформу нет.
Различия, в несколько процентов, в производительности, несущественны.</p>

  <p>Навеяно “мини-наездом” на C++ на <a href="http://habrahabr.ru/post/111403/">Хабре</a></p>

  <p><strong>UPD:</strong> Кроме варианта, что C знаем лучше.</p>
</blockquote>

<p>В качестве ответа я накатал <a href="http://hashcode.ru/questions/174571#175019">небольшую простыню</a>,
которая мне самому настолько понравилась, что решил что стоит её продублировать здесь.</p>

<blockquote>
  <p>Всем привет, расскажу почему я считаю что Си лучше C++. И почему надмножество над другим языком это не всегда хорошо.</p>

  <p><img src="http://yosefk.com/c++fqa/images/cat.png" alt="C++ FQA" title="C++ FQA" /></p>

  <p><a href="http://yosefk.com/c++fqa/">больше драмы</a></p>

  <p>Язык программирования всегда имеет набор фич. Замечено, что чем меньше фич и чем больше соблюдается ортогональность, тем гибче и выразительнее сам язык, тем легче понимать код.</p>

  <p>Возьмём к примеру Си: <strong>функции, структуры, указатели, макросы</strong>.
По-большому счёту это всё, примитивные типы можно считать примером структуры из одного элемента. Довольно быстро привыкаешь и понимаешь как каждая из этих фич взаимодействует между собой:</p>

  <ul>
    <li><strong>функции, указатели</strong>: указатели на функции, функция принимающая указатели</li>
    <li><strong>функции, структуры, указатели</strong>: структуры содержащие указатели на функции</li>
  </ul>

  <p>Макросы никак не взаимодействуют с другими, это просто препроцессор, поэтому тут всё понятно.</p>

  <p>И так, можно довольно быстро начать понимать код на Си, т.к. в нём используется ограниченный набор ортогональных фич, хорошо взаимодействующих между собой.</p>

  <p>Теперь рассмотрим C++: <strong>функции, структуры, указатели, макросы, классы, шаблоны, ссылки, исключения, операторы, методы</strong>.</p>

  <p>Где есть неортогональные пары, которые очень похожи, частично дублируют своё назначение, из-за этого иногда может быть непонятно где какую из двух использовать, код где сталкиваются две фичи может выглядеть криво или быть труднопонятным:</p>

  <ul>
    <li><em>указатели и ссылки</em></li>
    <li><em>структуры и классы</em></li>
    <li><em>макросы и шаблоны</em></li>
    <li><em>функции и методы</em></li>
  </ul>

  <p>Количество фич возросло, да ещё и половина из них неортогональна. Из-за этого программисту приходится делать выбор там, где в других языках за него выбрали проектировщики языка. C++ на порядок более сложный язык.</p>

  <p>Может быть кто-то скажет: “Ну и фиг что сложный! Я умный, я осилю, я смогу управлять этой мощью!”, может и действительно осилит. Я бы избегал любых лишних мысленных телодвижений. </p>

  <p>Си легче понимать и это серьёзное преимущество, в реальной жизни время и силы ограничены, если конечно их не тратить на троллинг на форумах, прихлебывая мамкин борщ.</p>
</blockquote>

<p>Такие дела.</p>

<p>PS: Линус на словцо горяч и не так вежлив как я, и если не читали, то <a href="http://article.gmane.org/gmane.comp.version-control.git/57918">это стоит прочесть</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Немного привёл блог в порядок]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/11/24/blog-updated/"/>
    <updated>2012-11-24T16:26:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/11/24/blog-updated</id>
    <content type="html"><![CDATA[<p>Включил тему <a href="https://github.com/octopress-themes/blanket">blanket</a> для <a href="http://octopress.org/">octopress</a>, немного подтюнинговал. Немного поменял шрифты, прописал тащить с Google Web Fonts кириллицу, достаточно добавить параметр <code>&amp;subset=latin,cyrillic</code> в <code>/source/_includes/custom/head.html</code>.</p>

<p>Таки добавил явную ссылку для комментирования, теперь не нужно быть вангой чтобы понять что посты можно комментить.</p>

<p>Поменял в шрифт заголовка с <a href="http://www.google.com/webfonts/specimen/Lobster">Lobster</a> на <a href="http://www.google.com/webfonts/specimen/Marmelad">Marmelad</a>.</p>

<p>Вообще, Octopress чертовски удобный инструмент для генерации статичного блога,
очень легко настраивается под себя.</p>

<p>Всё собирался написать про шаблонизатор <a href="https://github.com/vladimir-vg/elk.erl">Mustache для Erlang</a> который я написал ещё 4 месяца назад, да всё руки не доходили. Постараюсь запилить следующим постом.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Повторное использование кода в gamedev. Возможно?]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/10/04/gamedev-framework/"/>
    <updated>2012-10-04T14:56:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/10/04/gamedev-framework</id>
    <content type="html"><![CDATA[<p>Ещё совсем недавно веб был совсем другой: скрипты хостились на shared-хостингах
где набор доступных библиотек жёстко фиксировался хостером, и везде правил <a href="http://en.wikipedia.org/wiki/PHP">PHP</a>.</p>

<p>Огромный зоопарк фреймворков, несовместимых библиотек, некоторые из которых
требовали специальных опций в <code>php.ini</code> для своей работы, некоторые работали
только под определёнными версиями PHP. В общем прелесть.</p>

<p>С появлением «ООП» в PHP стало лучше, жить стало веселее, люди стали создавать фреймворки
соревнуясь с джавистами в обобщённости и абстрактности. В итоге всё это было
похоже на огромную несовместимую кучу говна.</p>

<p>Потом что-то изменилось. Возможно потому что VPS вошли в моду и стали
повсеместно доступны, может ещё что-то. Так или иначе <a href="http://rubyonrails.org/">Ruby on Rails</a> стал
набирать популярность.</p>

<p>Думаю никто не станет спорить, что сегодня RoR является наиболее комфортной
платформой для веб-разработки:</p>

<ul>
  <li>Строгое разделение кода по функциональности. <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> во все поля.</li>
  <li>Тесты, тесты, тесты. Множество фреймворков для тестирования,
сложившаяся культура в сообществе.</li>
  <li>Гибкое управление пакетами (rubygems &amp; bundler), использование специальных
версий библиотек не доставляет боли.</li>
  <li>Огромное количество библиотек, в первую очередь для вебаю</li>
</ul>

<p>И уже не важно тормозит Ruby или нет (по последним бенчмаркам он сравнялся с Python).
Этот недостаток перевешивают преимущества, так необходимые для реальной разработки.</p>

<p>Конечно Rails не панацея, он может не подходить для некоторых проектов, однако
большую часть веб-проектов быстрее и легче писать на Rails.</p>

<p>Таким образом, на мой взгляд, неупорядоченный и несовместимый веб стал упорядоченным.
Взросла определённая культура среди разработчиков.</p>

<h1 id="gamedev">А теперь взглянем на gamedev</h1>

<p>Там сложилась очень похожая ситуация что и недавно в вебе.</p>

<!--more-->

<p>Игры принято писать на С++. Это мультипарадигменный язык, на нём можно писать
в различных стилях: можно использовать дикую шаблонную магию в стиле <a href="http://www.boost.org/">boost</a>,
можно с любовью городить монструозную иерархию классов, как привыкли джависты,
можно вообще писать в сишном стиле, только структуры и функции, только хардкор.</p>

<p>Открывая любой проект написанный на C++ вы не можете знать наверняка
с чем вам придётся столкнуться.</p>

<p><a href="http://en.wikipedia.org/wiki/C%2B%2B11">Новый стандарт C++</a> подливает масла в огонь,
и если вы ещё не познакомились с новвоведениями,
то чей-нибудь код может надолго вогнать вас в ступор.</p>

<p>Один мой приятель рассказывал как работая над одним проектом неожиданно
обнаружил что он требует патченую версию библиотеки, отличную
от той что лежит в официальном репозитории. Обнаружилось это только
когда приложение спустя некоторое время стало валиться.</p>

<p>В Rails мире такая проблема решается просто: форк проекта с наложением патча
и инструкция в <code>Gemfile</code> с требованием использовать код из нашего репозитория.
Всё.</p>

<p>В мире C++ такая информация передаётся из уст в уста, или в файликах README,
как в старые добрые времена. Плохо когда нет автоматического управления зависимостями.
Очень плохо.</p>

<p>Культура тоже сложилась не ахти какая. Тестировать код (автоматическими тестами)
– скорее исключение чем правило. Зато повсюду принято писать
микрооптимизации, некоторые умудряются вставлять куски кода на асме,
всё потому что “так быстрее работает”, разумеется не подкрепляя утверждения
никакими бенчмарками.</p>

<p>Очень похоже на ситуацию что я описывал выше. Разброд и шатание,
блядство-разврат-наркотики.</p>

<h1 id="section">И как сделать лучше?</h1>

<p>Ясно что C++ здесь не подходит.
Очевидно что это должен быть язык, реализация которого достаточно быстро
оперирует с числами, но при этом без багажа C++. Язык достаточно гибкий
для создания сложной, расширяемой архитектуры. 
В идеале это должен быть язык работающий и под iOS и под Android.
Правда не уверен возможно ли это.</p>

<p>Мне нравится пророчить Go на это место.
Перечитав строки выше понял что JavaScript вроде бы тоже подходит.</p>

<p>Идём дальше. Нужно создать фреймворк на этом этом языке, где было бы строгое
разбиение кода по функционалу, что-то подобное MVC.</p>

<p><a href="http://en.wikipedia.org/wiki/Convention_over_configuration">Convention-over-configuration</a>
это вторая вещь которой следует научиться у Rails,
дерево исходных кодов должно быть фиксированным для всех проектов,
чтобы любой разработчик знал где искать какие часть проекта, даже увидев его впервые.</p>

<p>Если подумать, то похоже игровой код может лечь в MVC:</p>

<ul>
  <li>
    <p>World/Models – здесь хранится весь мир, игровые объекты, их состояние и характеристики,
игровые координаты. Для каждого world определён метод <code>process</code>, который обрабатывает
действия в мире с течением времени. Частота обработки фиксируется при подлючении этого
world. Также World должен отвечать за обработку физики.</p>

    <p>Большая часть логики кода должна быть записана здесь.</p>
  </li>
  <li>
    <p>View – код отвечающий за отрисовку конкретных объектов на экране. Список объектов
необходимо запрашивать у world. Шейдерная магия также определяется здесь.
У каждого из view должен быть метод <code>draw</code> который вызывается по таймеру.</p>
  </li>
  <li>
    <p>Controller – набор обработчиков событий, как внутриигровых, так и устройств ввода,
а также обработку пакетов из сети.</p>
  </li>
</ul>

<p>К примеру если потребуется сделать игровой сервер, то он мог
бы иметь несколько World-ов обрабатываемых одновременно, и не иметь никаких
view (и вовсе не иметь видеокарты). Для сервера пришлось бы дописать несколько
контроллеров работающих с сетью, но в целом, код тот же что и на клиенте.</p>

<p>Итог: весь пост это моё имхо, я только пробую себя в gamdev,
если где спорол херню – кидайте какашки в комментах.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Каким должен быть современный браузерный язык]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/07/02/modern-browser-language/"/>
    <updated>2012-07-02T21:38:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/07/02/modern-browser-language</id>
    <content type="html"><![CDATA[<h2 id="javascript">Или что меня не устраивает в JavaScript</h2>

<p>На самом деле в JavaScript много разных мелких неприятностей которые немного
мешают жить, но в целом это не является весомым поводом для того чтобы его
отринуть. И тем не менее я хочу кое-что пересмотреть. Выпилить нахер eval,
сделать код более строгим, всячески облагородить.</p>

<p>Вполне возможно мною движет <a href="http://lurkmore.to/NIH">NIH-синдром</a>,
однако я попробую доказать что это не так:</p>

<h2 id="section">Модульность</h2>

<p>Браузерный код усложнился достаточно для того чтобы потребовалась
модульная система. <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">Вообще-то кое-что уже появилось</a>,
так что этот пункт засчитывается как плюс-минус.</p>

<p>Типичный вебсайт сегодня — пачка jQuery-плагинов повязанных событиями.
Модульная система должна давать возможности для расцвета зоопарка различных
плагинов, а также безопасного из совмещения.
(Лексическая область видимости для каждого модуля,
<a href="http://semver.org/">“умное версионирование”</a>).</p>

<h2 id="section-1">Система типов</h2>

<p>Здесь выбор за <a href="http://c2.com/cgi/wiki?SoftTyping">SoftTyping</a>.</p>

<p>Причина та же что и в предыдущем пункте (сложность): необходимы стандартные средства
для проверки типов. Конечно не стоит устраивать такую содомию как в <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>,
достаточно опциональных аннотаций. (привет <a href="http://www.dartlang.org/">Dart</a>!)</p>

<h2 id="section-2">Простая структура кода</h2>

<p>Неоднозначная фраза, под ней я имел ввиду возможность легко отследить
зависимости в коде. Куча асинхронного кода динамически повязанного с событиями
— дикая лапша. Отлаживать такое — то ещё удовольствие.</p>

<p>Предыдущие два пункта были довольно косвенными, их можно решить без смены языка.
Этот нет.</p>

<p>Язык должен быть более строг что касается событий. Например будет обязывать
описывать все события в одном месте (модуля).</p>

<p>Кроме того желательно код писать чистым и изолированным, чтобы можно было легко
выделить только необходимые части кода, ужать размер.</p>

<p>Поэтому тут выбор за функциональным программированием. Ну и дебажить такое будет
заметно легче. Мне представляется что-то похожее на <a href="http://www.erlang.org/">Erlang</a>. (Без процессов, конечно).</p>

<h1 id="coffeescripthttpcoffeescriptorg--darthttpwwwdartlangorg"><a href="http://coffeescript.org/">CoffeeScript</a> и <a href="http://www.dartlang.org/">Dart</a></h1>

<p>Два языка которые пытаются улучшить JavaScript. Coffee просто предлагает более
приятный для глаз синтаксис, более читаемый. Dart пытается сделать какие-то
более радикальные изменения, хотя мне кажется что всё осталось по старому.
На мой поверхностный взгляд Dart таки предлагает большую структурированность.
(Однако event-hell сохраняется). Короче не то что нужно. Не то что я хочу.</p>

<p>Само собой я не прав.</p>

<p>Как-то так.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mustache, шаблонизатор лишённый логики]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/05/29/mustache-overview/"/>
    <updated>2012-05-29T12:53:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/05/29/mustache-overview</id>
    <content type="html"><![CDATA[<p>Наверное вы уже видели <a href="http://mustache.github.com/">Mustache</a>?
Это удобный шаблонизатор, имеющий множество реализаций для различных платформ
и исповедующий принцип: «Шаблоны без логики» (logic-less templates).
Сейчас немного расскажу что это такое и почему это круто.</p>

<p>Если вы когда-нибудь видели простыню php-кода где весело перемешаны вызовы к
БД, обращения к каким-то глобальным переменным, вывод html-шаблона – всё-всё
строк эдак в тыщу? Я видел. Это добро к тому же это ещё и постоянно ломалось
где-то посередине.</p>

<p>Подобные вещи оставляют глубокое впечатление а также ясное понимание что код
<em>нужно</em> структурировать всегда (например с помощью MVC, может как-то иначе),
кроме редчайших случаев.</p>

<p>Mustache – это шаг в сторону большей структуризации. В PHP нет чёткого
разделения на обычный код и html-шаблоны, в <a href="http://rubyonrails.org/">Ruby/Rails</a>
есть erb для шаблонов, но даже там можно наварить кашу. Если вы используете Mustache
у вас просто нет шансов. Код отдельно, шаблоны отдельно,
только так, только хардкор! Вы даже не можете вызвать какой-то фильтр в шаблоне,
такой код необходимо писать вне шаблона.</p>

<p>Шаблонизатор принимает <a href="http://www.json.org/">JSON</a>-подобную структуру (вложенные словари, списки; строки, числа)
и буквально отображает данные на шаблон (разговорным языком, маппит).</p>

<p>Вот пара примеров:</p>

<!--more-->

<div><div class="CodeRay">
  <div class="code"><pre>Welcome, would you like some coffee?

{{#drinks?}}
  We can offer some of this:
  {{#drinks}}
    {{name}}
    {{#alcohol?}}
      (only if you older 21)
    {{/alcohol?}}
  {{/drinks}}
{{/drinks?}}
</pre></div>
</div>
</div>

<p>Это собственно шаблон.
Ниже несколько примеров входных данных (в формате <a href="http://yaml.org/">YAML</a>) и результата.</p>

<p>Здесь <code>drinks?</code> обычное поле, используется для проверки существования списка.
(Да, это один из костылей которые планируется исправить в Mustache 2.0)</p>

<p>Если попить нечего:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="head"><span class="head">---</span></span>
<span class="key">drinks?</span>: <span class="string"><span class="content">true</span></span>
<span class="key">drinks</span>: <span class="string"><span class="content">[]</span></span>
<span class="head"><span class="head">---</span></span>
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre>Welcome, would you like some milk?

  We can offer some of this:
</pre></div>
</div>
</div>

<p>Если таки есть:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="head"><span class="head">---</span></span>
<span class="key">drinks?</span>: <span class="string"><span class="content">true</span></span>
<span class="key">drinks</span>:
  - <span class="string"><span class="content">{ name: wine, alcohol?: true }</span></span>
  - <span class="string"><span class="content">{ name: milk }</span></span>
<span class="head"><span class="head">---</span></span>
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre>Welcome, would you like some milk?

  We can offer some of this:
    wine
      (only if you older 21)
    milk
</pre></div>
</div>
</div>

<p>Вот занятный пример того как работает вложенность контекстов, можно определить
<code>alcohol?</code> в самом верху (будет как по-умолчанию), и для различных частей
входных данных переопределять значение:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="head"><span class="head">---</span></span>
<span class="key">drinks?</span>: <span class="string"><span class="content">true</span></span>
<span class="key">drinks</span>:
  - <span class="string"><span class="content">{ name: wine }</span></span>
  - <span class="string"><span class="content">{ name: milk, alcohol?: false }</span></span>
<span class="key">alcohol?</span>: <span class="string"><span class="content">true</span></span>
<span class="head"><span class="head">---</span></span>
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre>Welcome, would you like some milk?

  We can offer some of this:
    wine
      (only if you older 21)
    milk
</pre></div>
</div>
</div>

<p>Вообще тэг <code>{&#123;&#35;thing}}</code> работает следующим образом:</p>

<ul>
  <li>Если это словарь, то отрисовать содержимое используя новый контекст, с этим
словарём.</li>
  <li>Если это список, то сделать то же что для обычного значения,
но для каждого элемента.</li>
  <li>Если <code>thing</code> ложное значение или пустой список – проигнорировать содержимое.</li>
  <li>Если не ложное, но не словарь и не список, просто отрисовать содержимое.</li>
</ul>

<p>Вот пример того, как можно отрисовать один элемент (не список из одного),
хотя изначально шаблон писался в надежде что <code>drinks</code> таки будет списком.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="head"><span class="head">---</span></span>
<span class="key">drinks?</span>: <span class="string"><span class="content">true</span></span>
<span class="key">drinks</span>: <span class="string"><span class="content">{ name: wine, alcohol?: true }</span></span>
<span class="head"><span class="head">---</span></span>
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre>Welcome, would you like some milk?

  We can offer some of this:
    wine
      (only if you older 21)
</pre></div>
</div>
</div>

<p>Разумеется у таких шаблонов есть плюсы:</p>

<ul>
  <li>Можно использовать на серверной стороне, а также скомпилировать в js-код
и отрисовывать в браузере данные, стянутые с помощью AJAX.
Удобно и не приходится дублировать код.</li>
  <li>Можно удобно верстать с правдоподобными тестовыми данными, (на другой платформе)
а потом легко подключить в проект. На случай если ваш верстальщик вендузятник.</li>
  <li>Приятно работать с одним шаблонизатором в разных проектах, на разных платформах.</li>
  <li>Структуризация и разбиение есть дело православное. Меньше бардака, больше
порядка.</li>
</ul>

<p>и минусы:</p>

<ul>
  <li>Вынуждает городить отдельные модули для какой-то мелкой фигни.
По-началу раздражает.</li>
  <li>Если не получается выразить что необходимо с помощью данных и набора partials,
то приходится городить уродливые костыли. У самого не случалось, но примеры
в сети встречались.</li>
</ul>

<p>На данный момент потихоньку <a href="http://writing.jan.io/mustache-2.0.html">назревает движуха</a>,
желание исправить некоторые косяки в дизайне Mustache и родить на свет заново
в виде Mustache 2.0.</p>

<p><a href="https://github.com/vladimir-vg/elk.erl">Вот здесь</a> потихоньку пилю реализацию
mustache на Erlang. (Рабочая версия будет объявлена отдельным постом)
Та что указывается как официальная (<a href="https://github.com/mojombo/mustache.erl">mustache.erl</a>)
недостаточно фитчастая.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord Store в Rails 3.2]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/05/24/activerecord-3.2-store/"/>
    <updated>2012-05-24T09:21:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/05/24/activerecord-3.2-store</id>
    <content type="html"><![CDATA[<p>Недавно довелось пользоваться <code>store</code>-атрибутами которые появились в последних
рельсах. На самом деле <code>store</code>-атрибуты довольно простая вещь: это поле в
таблице типа <code>text</code>, которое хранит сложные данные сериализованные в текстовом формате.
Подобное может быть очень полезно для множества различных настроек, для которых
не хочется создавать по отдельному столбцу в таблице.</p>

<p>Т.к. это просто кусок сериализованных данных, то никакого индексирования и поиска
по полям само-собой нет.
(В отличие от документно-ориентированной <a href="http://www.mongodb.org/">MongoDB</a>)</p>

<p>Вроде бы ничего особенного, главная фича в том, что с полями хранимыми с помощью
<code>store</code> можно работать также как с обычными полями: использовать в формах,
проводить валидацию. Примеры использования можно увидеть
<a href="http://web-l.nl/posts/12-rails-3-2-active-record-s-store">здесь</a>,
<a href="http://yearofmoo.com/2012/01/rails-3-2-and-active-record-store/">здесь</a> и
<a href="http://blog.rawonrails.com/2012/02/using-activerecordstore-with-rails-32.html">здесь</a>.</p>

<p>Мне понадобилось реализовать хранение расписания в таблице, просто набор
промежутков времени для каждого дня. Не хотелось создавать отдельную таблицу
для промежутков, гораздо проще было бы просто сериализовать через <code>store</code>.</p>

<p>Однако вылезла следующая проблема: непонятно как работать с этими данными на
клиентской стороне, через формы. Значения <code>store</code>-полей выводились как есть,
используя ruby-синтаксис, тогда как мне нужен был JSON.</p>

<p>К примеру</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">class</span> <span class="class">Activity</span> &lt; <span class="constant">ActiveRecord</span>::<span class="constant">Base</span>
  store <span class="symbol">:schedule</span>, <span class="key">accessors</span>: [<span class="symbol">:monday</span>]
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>и если присвоить полю <code>monday</code> значение <code>[{:start =&gt; "01:00am", :end =&gt; "02:00am"}]</code>
и вывести в форме через <code>&lt;%= f.input :monday %&gt;</code> то значение будет обычная
строка <code>[{:start =&gt; "01:00am", :end =&gt; "02:00am"}]</code>, тогда как мне нужны данные
в формате JSON для более удобной работы через JavaScript.</p>

<p>Сделал небольшой хак, позволяющий присваивать и получать JSON.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">class</span> <span class="class">Activity</span> &lt; <span class="constant">ActiveRecord</span>::<span class="constant">Base</span>
  store <span class="symbol">:schedule</span>

  <span class="keyword">def</span> <span class="function">schedule</span>
    map = <span class="predefined-constant">self</span>[<span class="symbol">:schedule</span>].map { |day, value| [day, JSON(value)] }
    <span class="constant">Hash</span>[map]
  <span class="keyword">end</span>

  [<span class="symbol">:monday</span>].each <span class="keyword">do</span> |day|
    define_method(<span class="symbol"><span class="symbol">:</span><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">#{</span>day<span class="inline-delimiter">}</span></span><span class="content">=</span><span class="delimiter">&quot;</span></span>) <span class="keyword">do</span> |value|
      value = value.to_json <span class="keyword">unless</span> value.kind_of? <span class="constant">String</span>
      <span class="predefined-constant">self</span>[<span class="symbol">:schedule</span>][day] = value
    <span class="keyword">end</span>

    define_method(day) <span class="keyword">do</span>
      <span class="predefined-constant">self</span>[<span class="symbol">:schedule</span>][day]
    <span class="keyword">end</span>
  <span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>Теперь можно получать и присваивать JSON через обычные accessors, а к объектам
обращаться с помощью <code>.schedule[:monday]</code>.</p>

<p>Не самое элегантное решение, но проблему решает.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Пять правил Роба Пайка]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/04/02/five-rules/"/>
    <updated>2012-04-02T17:17:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/04/02/five-rules</id>
    <content type="html"><![CDATA[<p>Наткнулся на <a href="http://users.ece.utexas.edu/~adnan/pike.html">пять правил программирования</a>,
написанных Робом Пайком:</p>

<blockquote>
  <ol>
    <li>You can’t tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don’t try to second guess and put in a speed hack until you’ve proven that’s where the bottleneck is.</li>
    <li>Measure. Don’t tune for speed until you’ve measured, and even then don’t unless one part of the code overwhelms the rest.</li>
    <li>Fancy algorithms are slow when n is small, and n is usually small. Fancy algorithms have big constants. Until you know that n is frequently going to be big, don’t get fancy. (Even if n does get big, use Rule 2 first.)</li>
    <li>Fancy algorithms are buggier than simple ones, and they’re much harder to implement. Use simple algorithms as well as simple data structures.</li>
    <li>Data dominates. If you’ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.</li>
  </ol>
</blockquote>

<p>Роб Пайк крутой чувак и я его очень уважаю. Он участвовал в разработке
операционных систем <a href="http://www.vitanuova.com/inferno/">Inferno</a>,
<a href="http://plan9.bell-labs.com/plan9/index.html">Plan 9</a>, а также языков
<a href="http://doc.cat-v.org/plan_9/2nd_edition/papers/alef/">Alef</a>,
<a href="http://www.vitanuova.com/inferno/limbo.html">Limbo</a>,
<a href="http://en.wikipedia.org/wiki/Newsqueak">Newsqueak</a>
и на данный момент занят языком <a href="http://golang.org/">Go</a>.</p>

<p>Перевод этих пяти правил:</p>

<ol>
  <li>
    <p>Никто не знает какая часть кода будет потреблять больше ресурсов.
Узкие места бывает в совершенно неожиданных точках, поэтому не пытайтесь
угадывать и как-то оптимизировать код до тех пор пока вы на деле не выяснили что эта часть действительно является узким местом.</p>
  </li>
  <li>
    <p>Измеряйте. Не пытайтесь оптимизировать пока вы не провели измерений.
И даже после этого, не оптимизируйте, пока не убедитесь что эта часть кода
тяжелее всего остального.</p>
  </li>
  <li>
    <p>Нетривиальные алгоритмы работают медленно если <script type="math/tex"> n </script> достаточно маленькое,
и обычно именно так и случается. Зато в них достаточно большие константы
сложности. Пока не убедитесь что <script type="math/tex"> n </script> будет достаточно большим, не усложняйте код
нетривиальными алгоритмами. (И даже если <script type="math/tex"> n </script> достаточно велико,
убедитесь что выполняется второе правило)</p>
  </li>
  <li>
    <p>В нетривиальных алгоритмах гораздо легче ошибиться и их гораздо
сложнее реализовать. Используйте простые алгоритмы и простые структуры данных.</p>
  </li>
  <li>
    <p>Данные важнее кода. Если вы правильно подберёте структуры данных,
то код будет почти очевидным. Именно данные являются главной вещью в программировании, а не код.</p>
  </li>
</ol>

<p>Повесил на стенку.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rename watcher -> go-retest]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/03/17/go-retest-repository/"/>
    <updated>2012-03-17T16:46:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/03/17/go-retest-repository</id>
    <content type="html"><![CDATA[<p>Небольшой watcher описанный <a href="http://vladimir-vg.github.io/blog/2012/03/14/test-runner-watcher-for-go/">в предыдущем посте</a>
теперь называется <code>go-retest</code>, вызывается одноимённой командой и живёт по
адресу: <a href="https://bitbucket.org/vladimir_vg/go-retest">https://bitbucket.org/vladimir_vg/go-retest</a></p>

<p>На самом деле там почти нет ничего такого особенного, из-за чего стоило
заводить отдельный репозиторий. Тем не менее, вещь в быту полезная, может
будет постепенно обрастать фичами. (например анализ сорцов, вызов только необходимых тестов).</p>

<p>Чем чёрт не шутит.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Постоянный прогон тестов для Go]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/03/14/test-runner-watcher-for-go/"/>
    <updated>2012-03-14T01:20:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/03/14/test-runner-watcher-for-go</id>
    <content type="html"><![CDATA[<p>Понадобилась мне небольшая тулза, которая бы перезапускала тесты при изменениях
кода, а также уведомляла об ошибках. Проще говоря мне нужено что-то вроде
<a href="https://github.com/seattlerb/autotest-rails">autotest для Rails</a> или
<a href="https://github.com/mynyml/watchr">watchr</a>.</p>

<p>Накидал небольшой код который мониторит все <code>*.go</code> файлы и запускает тексты.
Использовал последний свежий Go из репозитория. Использовал команду <code>notify-send</code> для системных
уведомлений, гарантированно работает на Ubuntu Oneric 11.10. Если есть у кого
желание, то можно форкнуть <a href="https://gist.github.com/2032240">gist</a> и добавить
функции системного уведомления для вашей системы.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">log</span><span class="delimiter">&quot;</span></span>
<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">os</span><span class="delimiter">&quot;</span></span>
<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">regexp</span><span class="delimiter">&quot;</span></span>
<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">os/exec</span><span class="delimiter">&quot;</span></span>
<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">exp/inotify</span><span class="delimiter">&quot;</span></span>

<span class="keyword">func</span> runTests() {
    cmd := exec.Command(<span class="string"><span class="delimiter">&quot;</span><span class="content">go</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>)
    cmd.Stdout = os.Stdout
    <span class="keyword">if</span> err := cmd.Run(); err != <span class="predefined-constant">nil</span> {
        log.Println(err)
        notifySystem(<span class="string"><span class="delimiter">&quot;</span><span class="content">go test failed</span><span class="delimiter">&quot;</span></span>)
    }
}

<span class="comment">// probably will work only for Ubuntu</span>
<span class="keyword">func</span> notifySystem(message <span class="predefined-type">string</span>) {
    cmd := exec.Command(<span class="string"><span class="delimiter">&quot;</span><span class="content">notify-send</span><span class="delimiter">&quot;</span></span>, message)
    <span class="keyword">if</span> err := cmd.Run(); err != <span class="predefined-constant">nil</span> {
        log.Fatal(err)
    }
}

<span class="keyword">func</span> setupWatcher() *inotify.Watcher {
    watcher, err := inotify.NewWatcher()
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        log.Fatal(err)
    }

    err = watcher.AddWatch(<span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span>, inotify.IN_MODIFY)
    <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
        log.Fatal(err)
    }

    <span class="keyword">return</span> watcher
}

<span class="keyword">func</span> main() {
    watcher := setupWatcher()

    runTests()
    <span class="keyword">for</span> {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> ev := &lt;-watcher.Event:
            matched, err := regexp.MatchString(<span class="string"><span class="delimiter">&quot;</span><span class="content">.*</span><span class="char">\\</span><span class="content">.go</span><span class="delimiter">&quot;</span></span>, ev.Name)
            <span class="keyword">if</span> err != <span class="predefined-constant">nil</span> {
                log.Fatal(err)
            }

            <span class="keyword">if</span> matched {
                <span class="comment">// On my machine it always raised two events</span>
                <span class="comment">// ignore second, prevent twice tests run.</span>
                <span class="comment">// Probably it's depends of test editor.</span>
                <span class="comment">// If so, feel free to</span>
                <span class="comment">// remove line above:</span>
                &lt;-watcher.Event

                runTests()
            }
        <span class="keyword">case</span> err := &lt;-watcher.Error:
            log.Println(<span class="string"><span class="delimiter">&quot;</span><span class="content">error:</span><span class="delimiter">&quot;</span></span>, err)
        }
    }
}
</pre></div>
</div>
</div>

<p><strong>UPD:</strong> Теперь watcher живёт по адресу:
<a href="https://bitbucket.org/vladimir_vg/go-retest">https://bitbucket.org/vladimir_vg/go-retest</a>.
Подробнее <a href="http://vladimir-vg.github.io/blog/2012/03/17/go-retest-repository/">в следующем посте</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Странное поведение выражения с if в Ruby]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/03/11/strange-ruby-if/"/>
    <updated>2012-03-11T15:37:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/03/11/strange-ruby-if</id>
    <content type="html"><![CDATA[<p>Первым делом код:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">class</span> <span class="class">A</span>
  <span class="keyword">def</span> <span class="function">foo</span>
    <span class="symbol">:method_value</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">bar</span>
    foo = <span class="symbol">:variable_value</span> <span class="keyword">if</span> <span class="predefined-constant">false</span>
    foo
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>Если мы используем локальную переменную с таким же именем как и метод, то
метод перекрывается ею. В приведённом коде я ожидал возврата <code>:method_value</code>,
т.к. мы не используем переменную <code>foo</code>. Метод <code>bar</code> возвращает <code>nil</code>.
Забавно, правда?</p>

<p>Переиначил приведённый выше пример, но получил тот же результат:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">class</span> <span class="class">A</span>
  <span class="keyword">def</span> <span class="function">foo</span>
    <span class="symbol">:method_value</span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">bar</span>
    <span class="keyword">if</span> <span class="predefined-constant">false</span>
      foo = <span class="symbol">:variable_value</span>
    <span class="keyword">end</span>
    foo
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></div>
</div>
</div>

<p>Наверное эта «фича» находится в родственных связях с багом описанном в весёлом
<a href="https://www.destroyallsoftware.com/talks/wat">WAT видео</a>:</p>

<div><div class="CodeRay">
  <div class="code"><pre>1.9.2p290 :001 &gt; a
NameError: undefined local variable or method `a' for main:Object
1.9.2p290 :002 &gt; b
NameError: undefined local variable or method `b' for main:Object
1.9.2p290 :003 &gt; a = b
NameError: undefined local variable or method `b' for main:Object
1.9.2p290 :004 &gt; a
 =&gt; nil
</pre></div>
</div>
</div>

<p>После того как мы просто попытались использовать необъявленные переменные одна
из них магическим образом объявилась.</p>

<p>WAT?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Сравнение функций в Go]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/03/10/compare-funcs-in-go/"/>
    <updated>2012-03-10T11:26:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/03/10/compare-funcs-in-go</id>
    <content type="html"><![CDATA[<p>Мне всегда казалось естественным сравнивать функции в языках с поддержкой
ФВП. Понятное дело, что сравнить ведут ли себя функции одинаково, в одинаковый
код ли они скомпилировались дело сложное и, в действительности, не нужное.
Но почему бы не сравнивать их указатели? Возвращать <code>true</code> когда это
гарантированно так.</p>

<p>Некоторое время назад, разбираясь с <a href="http://www.haskell.org/">Haskell</a> я поднимал
<a href="http://www.linux.org.ru/forum/development/5452398">тему на ЛОРе</a>.</p>

<p>Сейчас пишу небольшой проект на <a href="http://golang.org/">Go</a> и наткнулся на ту же
проблему. Даже
<a href="https://groups.google.com/d/topic/golang-nuts/CSS0pB8KwhQ/discussion">задал вопрос в списке рассылки</a>,
и в ходе обсуждения выяснилось что это может связать руки компилятору в
создании некоторых оптимизаций. (Например если компилятор захочет сделать inline).</p>

<p>Так что этого стоит избегать.</p>

<p>Пока я выяснял степень православности сравнения указателей функций, я накалякал
вот такой костылик:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">reflect</span><span class="delimiter">&quot;</span></span>
<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fmt</span><span class="delimiter">&quot;</span></span>

<span class="keyword">func</span> f() {}
<span class="keyword">func</span> g() {}

<span class="keyword">func</span> equals(f, g <span class="keyword">interface</span>{}) <span class="predefined-type">bool</span> {
    fPtr := reflect.ValueOf(f).Pointer()
    gPtr := reflect.ValueOf(g).Pointer()
    <span class="keyword">return</span> fPtr == gPtr
}

<span class="keyword">func</span> main() {
    <span class="keyword">if</span> equals(f, g) {
        fmt.Println(<span class="string"><span class="delimiter">&quot;</span><span class="content">f and g are equal!</span><span class="delimiter">&quot;</span></span>)
    } <span class="keyword">else</span> {
        fmt.Println(<span class="string"><span class="delimiter">&quot;</span><span class="content">f and g are not equal.</span><span class="delimiter">&quot;</span></span>)
    }
}
</pre></div>
</div>
</div>

<p>Ответ разумеется <code>"f and g are not equal."</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Всем привет! Снова.]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/02/05/hello-there-again/"/>
    <updated>2012-02-05T16:19:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/02/05/hello-there-again</id>
    <content type="html"><![CDATA[<p>Похоже что вести блог на английском для меня пока непосильная задача. Конечно
я могу писать на английском, но текст непременно будет содержать ошибки.</p>

<p>Также важна аудитория. В сети полно блогов на английском языке, смогу ли я
поделиться чем-то ценным с англоязычной аудиторией? Это сделать труднее
чем для русскоязычной.</p>

<p>Кроме того, в сети полно статей, заслуживающих внимания, но доступных лишь на
английском языке. Было бы доброй услугой перевести их.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[init]]></title>
    <link href="http://vladimir-vg.github.io/blog/2012/01/26/init/"/>
    <updated>2012-01-26T16:00:00+03:00</updated>
    <id>http://vladimir-vg.github.io/blog/2012/01/26/init</id>
    <content type="html"><![CDATA[<p>Hello there, this is my first post in this blog. Actually I wrote it mostly for
testing purposes rather than to provide some kind of information.</p>

<p>btw, English isn’t my native language, so probably my texts may contain
grammatical mistakes. I will be glad to accept your pull-request with fixes.</p>

]]></content>
  </entry>
  
</feed>
